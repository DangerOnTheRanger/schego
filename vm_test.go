package schego

import (
	"strings"
	"testing"
)

type DummyConsole struct {
	consoleOutput string
}

func (d *DummyConsole) Write(line string) {
	// trim null
	d.consoleOutput = strings.TrimRight(line, "\x00")
}

func StepVM(vm *VMState, count int) {
	for i := 0; i < count; i++ {
		vm.Step()
	}
}

func TestHelloWorld(t *testing.T) {
	opcodes := []byte{
		0x05, // pushs
		0x48, // H
		0x65, // e
		0x6C, // l
		0x6C, // l
		0x6F, // o
		0x2C, // ,
		0x20, // space
		0x57, // W
		0x6F, // o
		0x72, // r
		0x6C, // l
		0x64, // d
		0x21, // !
		0x0A, // \n
		0x00, // null
		0x43, // syscall
		0x05, // print string
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	retcode := RunVM(opcodes, &console)
	if retcode != 0 {
		t.Error("Expected return code of 0, got:\n", retcode)
	}
	if console.consoleOutput != "Hello, World!\n" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestHelloUnicode(t *testing.T) {
	opcodes := []byte{
		0x05, // pushs
		0xE3,
		0x81,
		0x93, // こ
		0xE3,
		0x82,
		0x93, // ん
		0xE3,
		0x81,
		0xAB, // に
		0xE3,
		0x81,
		0xA1, // ち
		0xE3,
		0x81,
		0xAF, // は
		0xE4,
		0xB8,
		0x96, // 世
		0xE7,
		0x95,
		0x8C, // 界
		0x21, // !
		0x0A, // \n
		0x00, // null
		0x43, // syscall
		0x05, // print string
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "こんにちは世界!\n" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestDouble(t *testing.T) {
	opcodes := []byte{
		0x04, // pushd
		0x18,
		0x2D,
		0x44,
		0x54,
		0xFB,
		0x21,
		0x09,
		0x40, // pi (3.141592653589793)
		0x43, // syscall
		0x04, // print double
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "3.141592653589793" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestUnconditionalJump(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi
		0x04,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 4
		0x2C, // jmp
		0x09,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 9 - skip the pushi below
		0x03, // pushi
		0xDE,
		0xAD,
		0xBE,
		0xEF,
		0xDE,
		0xAD,
		0xBE,
		0xEF,
		0x43, // syscall
		0x03, // print integer (the 4 from earlier)
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "4" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestCompareInt(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi (our x value)
		0x0A,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 10
		0x03, // pushi (our y value)
		0x09,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x40, // cmpi
	}
	console := DummyConsole{}
	vm := NewVM(opcodes, &console)
	StepVM(vm, 3)
	topByte := vm.Stack.PopByte()
	if topByte != 1 {
		t.Error("Incorrect output, got: ", topByte)
	}
}

func TestJumpNotEqual(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi
		0x0C,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 12
		0x03, // pushi
		0x0C,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 12
		0x40, // cmpi
		0x2D, // jne
		0x0A,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 10 - skip the pushs, will (or should!) never happen
		0x05, // pushs
		0x4E, // N
		0x6F, // o
		0x20, // space
		0x6A, // j
		0x75, // u
		0x6D, // m
		0x70, // p
		0x0A, // \n
		0x00, // null
		0x43, // syscall
		0x05, // print string
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "No jump\n" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestDup(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi
		0x07,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 7
		0x07, // dup
		0x40, // cmpi
	}
	console := DummyConsole{}
	vm := NewVM(opcodes, &console)
	StepVM(vm, 3)
	topByte := vm.Stack.PopByte()
	if topByte != 0 {
		t.Error("Incorrect output, got: ", topByte)
	}
}

func TestAddInteger(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi
		0x07,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 7
		0x03, // pushi
		0x03,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 3
		0x36, // addi
	}
	console := DummyConsole{}
	vm := NewVM(opcodes, &console)
	StepVM(vm, 3)
	addResult := vm.Stack.PopInt()
	if addResult != 10 {
		t.Error("Incorrect output, got: ", addResult)
	}
}

func TestJumpReverse(t *testing.T) {
	// loop from 0 to 42, inclusive
	opcodes := []byte{
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x2C, // jmp
		0x0A,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 10 (skip the increment on the first run)
		0x03, // pushi
		0x01,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 1
		0x36, // addi
		0x07, // dup
		0x03, // pushi
		0x2A,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 42
		0x40, // cmpi
		0x2D, // jne
		0xE2,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF, // -30 (back to the pushi 1)
		0x43, // syscall
		0x03, // print integer
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "42" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestHeapInt(t *testing.T) {
	opcodes := []byte{
		0x22, // hnewi
		0xBE,
		0xEF, // 2-byte reference mnemonic (0xBEEF)
		0x03, // pushi
		0x0A,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 10
		0x0A, // hstorei
		0xBE,
		0xEF, // 0xBEEF
		0x03, // pushi
		0xFF,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 255
		0x16, // hloadi
		0xBE,
		0xEF, // 0xBEEF
		0x43, // syscall
		0x03, // print integer
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "10" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}

func TestHeapString(t *testing.T) {
	opcodes := []byte{
		0x03, // pushi
		0x06,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 6
		0x24, // hnews
		0xBE,
		0XEF, // reference mnemonic - 0xBEEF
		0x05, // pushs
		0x53, // S
		0x68, // h
		0x6F, // o
		0x72, // r
		0x74, // t
		0x00, // null
		0x0C, // hstores
		0xBE,
		0xEF, // reference mnemonic - 0xBEEF
		0x05, // pushs
		0x4C, // L
		0x6F, // o
		0x6E, // n
		0x67, // g
		0x65, // e
		0x72, // r
		0x00, // null
		0x0C, // hstores
		0xBE,
		0xEF, // reference mnemonic - oxBEEF
		0x05, // pushs
		0x4A, // J
		0x75, // u
		0x6E, // n
		0x6B, // k
		0x00, // null
		0x18, // hloads
		0xBE,
		0xEF, // reference mnemonic - 0xBEEF
		0x43, // syscall
		0x05, // print string
		0x03, // pushi
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00, // 0
		0x43, // syscall
		0x06, // exit
	}
	console := DummyConsole{}
	RunVM(opcodes, &console)
	if console.consoleOutput != "Longer" {
		t.Error("Incorrect output, got: ", console.consoleOutput)
	}
}
